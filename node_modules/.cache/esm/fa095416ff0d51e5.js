let Joi,bcrypt,Item,jsonwebservise;_ff0‍.x([["default",()=>_ff0‍.o]]);_ff0‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_ff0‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_ff0‍.w("../Model/Item",[["default",["Item"],function(v){Item=v}]]);_ff0‍.w("../../Rest Api/error/jsonwebtoken",[["default",["jsonwebservise"],function(v){jsonwebservise=v}]]);





const registerController = {
  async register(req, res, next) {
    const registerSchema = Joi.object({
     
      email: Joi.string().email().required(),
      password: Joi.string().required(),
      reppassword: Joi.ref("password"),
    });

    const { error } = registerSchema.validate(req.body);
    if (error) {
      return next(error);
    }

    // User Already Exist....

    try {
      const exist = await Item.exists({ email: req.body.email });

      if (exist) {
        return next(new Error("User Already Exist."));
      }
    } catch (error) {
      return next(error);
    }

    // bcrypt password...
    const { email, password } = req.body;

    const hasdPassword = await bcrypt.hash(password, 10);

    let user = new Item({
     
      email,
      password: hasdPassword,
    });

    // save code......
    let access_jwt_token;

    try {
      user = await user.save();

      access_jwt_token = jsonwebservise.sign({ _id: user._id });
    } catch (error) {
      _ff0‍.g.console.log(error);
      return next(error);
    }

    res.json({ access_jwt_token });
  },
};
_ff0‍.d(registerController);
